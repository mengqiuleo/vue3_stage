{"version":3,"file":"reactivity.global.js","sources":["../../shared/src/index.ts","../src/effect.ts","../src/baseHandlers.ts","../src/reactive.ts","../src/ref.ts"],"sourcesContent":["/*\r\n * @Author: Pan Jingyi\r\n * @Date: 2022-10-11 20:14:03\r\n * @LastEditTime: 2022-10-12 16:24:53\r\n */\r\n\r\nexport const isObject = (value) => typeof value == 'object' && value !== null;\r\nexport const extend = Object.assign\r\n\r\nexport const isArray = Array.isArray\r\nexport const isFunction = (value) => typeof value == 'function' \r\nexport const isNumber = (value) => typeof value == 'number'\r\nexport const isString = (value) => typeof value == 'string'\r\nexport const isIntegerKey = (key) => parseInt(key) + '' == key //判断一个属性是不是索引(针对数组)\r\n\r\nlet hasOwnProperty = Object.prototype.hasOwnProperty\r\nexport const hasOwn = (target, key) => hasOwnProperty.call(target,key) //判断对象身上有没有这个属性\r\n\r\nexport const hasChanged = (oldValue,value) => oldValue !== value //判断老值和新值是否一致","import { isArray, isIntegerKey } from \"@vue/shared\";\r\nimport { TriggerOrTypes } from \"./operators\";\r\n\r\n/*\r\n * @Author: Pan Jingyi\r\n * @Date: 2022-10-12 10:30:07\r\n * @LastEditTime: 2022-10-13 09:58:59\r\n */\r\nexport function effect(fn, options:any = {}){\r\n  // 我需要让这个effect变成响应的effect，可以做到effect里面的数据变化：重新执行\r\n\r\n  const effect = createReactiveEffect(fn, options);\r\n\r\n  if(!options.lazy){ //lazy表示这个effect是懒执行，默认的effect会先执行一次\r\n    effect();\r\n  }\r\n\r\n  return effect;\r\n}\r\n\r\nlet uid  = 0;\r\nlet activeEffect;//一个变量：存储当前属性的effect\r\nconst effectStack = []; //栈：effect函数中可能会嵌套effect，那么就需要栈来存储当前属性的effect（区分）\r\nfunction createReactiveEffect(fn, options){ //fn就是用户传入的函数\r\n  const effect = function reactiveEffect(){\r\n    if(!effectStack.includes(effect)){ //如果没有再加进去：保证effect没有加入到effectStack中\r\n      //如果出现异常，希望还可以正常的将栈中元素抛出去\r\n      try{\r\n        effectStack.push(effect); //将当前属性的effect入栈\r\n        activeEffect = effect; //存储当前属性的effect\r\n        //让effect上来先执行一次,执行的是我们传入的那个函数: 执行就会去我们设置的变量中取值 \r\n        return fn();\r\n      }finally{\r\n        effectStack.pop();\r\n        activeEffect = effectStack[effectStack.length-1]\r\n      }\r\n    }\r\n    \r\n  }\r\n  effect.id = uid++; //制作一个effect标识，用于区分effect\r\n  effect._isEffect = true; //用于标识这个effect是响应式effect\r\n  effect.raw = fn; //保留effect对应的原函数\r\n  effect.options = options; //在effect上保存用户的属性\r\n\r\n  return effect;\r\n}\r\n\r\n// 让 某个对象中的属性 收集当前它对应的effect函数\r\nconst targetMap = new WeakMap()\r\nexport function track(target, type, key){\r\n  //这里可以拿到当前属性的effect： activeEffect\r\n\r\n  if(activeEffect === undefined){ //该属性不用收集effect\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * targetMap代表的是所有对象的集合：里面的key是每一个target，value是这个target的map\r\n   * depsMap代表的是某个target的map：它的value是map，这个map是target的所有属性的集合\r\n   * dep就是从targetMap中根据key(这里的key就是target)，然后拿到对应的depsMap，然后根据key(key就是某个属性)，找到这个属性的set\r\n   * 注意：每个属性对应一个set，然后这个set里面放了它的effect（因为set可以去重，所以是set）\r\n   * 如果这个set里面没有当前的effect，那就加上\r\n   */\r\n  let depsMap = targetMap.get(target)\r\n  if(!depsMap){\r\n    targetMap.set(target, (depsMap = new Map()))\r\n  }\r\n  let dep = depsMap.get(key)\r\n  if(!dep){\r\n    depsMap.set(key, (dep = new Set))\r\n  }\r\n  if(!dep.has(activeEffect)){\r\n    dep.add(activeEffect)\r\n  }\r\n\r\n  console.log(targetMap)\r\n}\r\n\r\nexport function trigger(target, type, key?, newValue?, oldValue?){\r\n  // target：我们代理的整个对象  type: 0/1 -> 新增/修改   key: 新增或修改的属性\r\n  // console.log('执行set或add',type, key, newValue, oldValue)\r\n  \r\n  /**\r\n   * targetMap是整个对象(即：let obj = reactive({name:'zs', age:12, arr: [1,2,3]}) )\r\n   * 那么 targetMap 就是 {name:'zs', age:12, arr: [1,2,3]}\r\n   * \r\n   * 这里的传参的target比如是：arr\r\n   * 那么depsMap就是[1,2,3]，但其实浏览器会自动加上一些方法：valueOf, toString, join, length，然后才是每一项：1,2,3\r\n   * 对于depsMap来说：它也有key和value：\r\n   * key就是valueOf, toString, join, length，每一项... \r\n   * value是一个set：这个set的值是function reactiveEffect()，对于function reactiveEffect()，这个函数的返回值是一个effect\r\n   * 也就是说，对于每个key(valueOf, toString, join, length，每一项... ),它的值是一个set，里面是它的effect\r\n   * 因为一个属性可能有好几个effect，所以用set\r\n   */\r\n  const depsMap = targetMap.get(target)\r\n  // 如果这个属性没有收集过effect，那就不需要做任何操作：就像我们在effect中写了一个不是reactive的属性并对他做修改，\r\n  if(!depsMap) return;\r\n\r\n  const effects = new Set()\r\n  // 将所有的要执行的effect 全部存到一个新的集合中，最终一起执行：就是把当前属性所依赖的所有effect存起来\r\n  const add = (effectsToAdd) => {\r\n    if(effectsToAdd){ //effectsToAdd是一个set，里面放了当前属性的所有effect\r\n      effectsToAdd.forEach(effect => effects.add(effect))\r\n    }\r\n  }\r\n\r\n  // 1.看修改的是不是数组的长度（因为改长度影响比较大）\r\n  if(key === 'length' && isArray(target)){\r\n    depsMap.forEach((dep, key) => {\r\n      // depsMap对于数组：前几项都是：valueOf, toString, join, length,下面几项是数组的每一项\r\n      // dep：是一个set，上面的depsMap的每一项的value：这个set的值是function reactiveEffect()\r\n      // key：valueOf, toString, join \r\n      // console.log('depsMap: ',depsMap,'dep: ', dep,'key: ', key)\r\n\r\n      if(key === 'length' || key > newValue){\r\n        // 如果更改的长度 小于收集的索引，那么这个索引也需要触发effect重新执行\r\n        add(dep);\r\n        //dep是一个set，是当前key的所有effect的集合\r\n      }\r\n    })\r\n  } else {\r\n    //修改的是对象\r\n    if(key !== undefined){ //这里肯定是修改，不是新增\r\n      add(depsMap.get(key))\r\n    }\r\n    //如果修改数组中的 某一个索引 怎么办？\r\n    switch(type){\r\n      case TriggerOrTypes.ADD: //这种情况：原来arr:[1,2,3]  但是现在：arr[100]=1\r\n        if(isArray(target) && isIntegerKey(key)){ //如果是数组并且修改的索引大于数组的长度(上面首先判断的是修改索引小于数组长度的情况)\r\n          add(depsMap.get('length'))\r\n        }\r\n    }\r\n  }\r\n\r\n  //取出所有effect，遍历\r\n  effects.forEach((effect:any) => effect())\r\n}\r\n\r\n// { name:'zf', age=12 } => name => [effect effect]","/*\r\n * @Author: Pan Jingyi\r\n * @Date: 2022-10-11 21:54:42\r\n * @LastEditTime: 2022-10-13 09:25:45\r\n */\r\n// 是不是仅读的 仅读的属性set时会报异常\r\n// 是不是深度的\r\n\r\nimport { extend, hasOwn, isIntegerKey, isObject, isArray, hasChanged } from '@vue/shared/src'\r\nimport { track, trigger } from './effect';\r\nimport { TrackOpTypes, TriggerOrTypes } from './operators';\r\nimport { reactive, readonly } from \"./reactive\";\r\n\r\nfunction createGetter(isReadonly = false, shallow = false){ //拦截获取功能\r\n  return function get(target, key, receiver){\r\n    \r\n    const res = Reflect.get(target, key, receiver)\r\n\r\n    if(!isReadonly){\r\n      //收集依赖，等会儿数据变化后更新对应的视图\r\n      //这里相当于属性值的最外面的一层，下面才是如果里层是对象进行递归\r\n    \r\n      //每个属性都会去走一遍这个函数\r\n      console.log('执行effect时会取值，收集effect')\r\n      track(target, TrackOpTypes.GET, key) //调用get方法时，追踪target对象的key属性\r\n    }\r\n\r\n    if(shallow){\r\n      return res\r\n    }\r\n    //如果不是浅读并且当前属性值是对象\r\n    if(isObject(res)){\r\n      //递归：保证属性值里面的对象仍然是响应式的\r\n      // vue2是一上来就递归，vue3是取值时才会代理（懒代理），如果你不用这个值就不会代理\r\n      return isReadonly ? readonly(res) : reactive(res)\r\n    }\r\n\r\n    return res\r\n  }\r\n}\r\n\r\nfunction createSetter(shallow = false){ //拦截设置功能\r\n  return function set(target, key, value, receiver){\r\n    // 首先判断是新增还是修改\r\n    const oldValue = target[key]; //获取老的值\r\n\r\n    // 判断key是否是数组并且是数组索引，如果是，该索引是已存在的还是新增的，如果不是数组判断该对象的属性key是否存在\r\n    // 这里就对数组和对象进行了区分\r\n    //我们也不需要像vue2那样去重写数组方法：因为push方法也是修改数组索引\r\n    let hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target,key)\r\n    // hadKey 此时就判断出来了该key是新增的还是修改\r\n\r\n    const result = Reflect.set(target, key, value, receiver)\r\n\r\n    if(!hadKey){\r\n      //新增\r\n      trigger(target, TriggerOrTypes.ADD, key, value)\r\n    }else if(hasChanged(oldValue,value)){//判断老值和新值是否一致\r\n      //修改\r\n      trigger(target, TriggerOrTypes.SET, key, value, oldValue)\r\n    }\r\n\r\n    // vue2里无法监控更改索引，无法监控数组的长度\r\n    // 当数据更新时，通知对应属性的effect重新执行\r\n    return result\r\n  }\r\n}\r\n\r\nconst get = createGetter()\r\nconst shallowGet = createGetter(false, true)\r\nconst readonlyGet = createGetter(true)\r\nconst shallowReadonlyGet = createGetter(true, true)\r\n\r\nconst set = createSetter()\r\nconst shallowSet = createSetter(true)\r\n\r\nexport const mutableHandlers = {\r\n  get,\r\n  set\r\n}\r\nexport const shallowReactiveHandlers = {\r\n  get: shallowGet,\r\n  set: shallowSet\r\n}\r\n\r\nlet readonlyObj = {\r\n  set: (target, key) => {\r\n    console.warn(`set on key ${key} failed`)\r\n  }\r\n}\r\n\r\nexport const readonlyHandlers = extend({\r\n  get: readonlyGet\r\n}, readonlyObj)\r\n\r\nexport const shallowReadonlyHandlers = extend({\r\n  get: shallowReadonlyGet\r\n}, readonlyObj)","/*\r\n * @Author: Pan Jingyi\r\n * @Date: 2022-10-11 21:20:53\r\n * @LastEditTime: 2022-10-12 10:07:38\r\n */\r\n\r\nimport { isObject } from '@vue/shared/src'\r\n\r\nimport {\r\n  mutableHandlers,\r\n  shallowReactiveHandlers,\r\n  readonlyHandlers,\r\n  shallowReadonlyHandlers\r\n} from './baseHandlers'\r\n\r\n\r\nexport function reactive(target){\r\n  return createReactiveObject(target, false, mutableHandlers)\r\n}\r\n\r\nexport function shallowReactive(target){\r\n  return createReactiveObject(target, false, shallowReactiveHandlers)\r\n}\r\n\r\nexport function readonly(target){\r\n  return createReactiveObject(target, true, readonlyHandlers)\r\n}\r\n\r\nexport function shallowReadonly(target){\r\n  return createReactiveObject(target, true, shallowReadonlyHandlers)\r\n}\r\n\r\n//是不是仅读，是不是深度， 柯里化 new Proxy() 最核心的需要拦截 数据的读取和数据的修改\r\n\r\nconst reactiveMap = new WeakMap()\r\nconst readonlyMap = new WeakMap()\r\n\r\nexport function createReactiveObject(target, isReadonly, baseHandlers){\r\n  //如果目标不是对象，没法拦截， reactive这个api只能拦截对象类型\r\n  if(!isObject(target)){\r\n    return target;\r\n  }\r\n\r\n  // 如果某个对象已经被代理过了 就不要再次代理了\r\n  // 可能一个对象 被深度代理了 又是仅读代理\r\n  const proxyMap = isReadonly? readonlyMap : reactiveMap; \r\n\r\n  const existProxy = proxyMap.get(target)\r\n  if(existProxy){\r\n    return existProxy; //如果已经被代理了，直接返回即可\r\n  }\r\n\r\n  const proxy = new Proxy(target, baseHandlers)\r\n  proxyMap.set(target, proxy) //将要代理的对象 和 对应代理结果缓存起来\r\n\r\n  return proxy\r\n}","/*\r\n * @Author: Pan Jingyi\r\n * @Date: 2022-10-13 10:16:50\r\n * @LastEditTime: 2022-10-13 10:32:23\r\n */\r\n\r\n// ref将普通的类型 转化成一个对象，这个对象中有个value属性 指向原来的值\r\n// let name = ref('zf')   name.value\r\nexport function ref(value){\r\n  return createRef(value)\r\n}\r\n\r\n// ref和reactive的区别：reactive内部采用proxy ref内部使用的是defineProperty\r\n\r\nexport function shallowRef(value){\r\n  return createRef(value,true)\r\n}\r\n\r\nclass RefImpl { //ref返回的是一个RefImpl类的实例\r\n  public _value; //表示声明了一个_value属性，但是没有赋值\r\n  public __v_isRef = true; //产生的实例会被添加 __v_isRef 表示是一个ref属性\r\n  constructor(public rawValue, public shallow){ //参数前面添加修饰符，该属性会被直接放到实例上 可以直接this.xxx获取\r\n    \r\n  }\r\n}\r\n\r\nfunction createRef(rawValue, shallow = false){\r\n  return new RefImpl(rawValue, shallow)\r\n}"],"names":[],"mappings":"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"}