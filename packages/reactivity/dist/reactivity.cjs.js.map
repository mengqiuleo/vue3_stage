{"version":3,"file":"reactivity.cjs.js","sources":["../../shared/src/index.ts","../src/effect.ts","../src/baseHandlers.ts","../src/reactive.ts","../src/ref.ts"],"sourcesContent":["/*\r\n * @Author: Pan Jingyi\r\n * @Date: 2022-10-11 20:14:03\r\n * @LastEditTime: 2022-10-12 16:24:53\r\n */\r\n\r\nexport const isObject = (value) => typeof value == 'object' && value !== null;\r\nexport const extend = Object.assign\r\n\r\nexport const isArray = Array.isArray\r\nexport const isFunction = (value) => typeof value == 'function' \r\nexport const isNumber = (value) => typeof value == 'number'\r\nexport const isString = (value) => typeof value == 'string'\r\nexport const isIntegerKey = (key) => parseInt(key) + '' == key //判断一个属性是不是索引(针对数组)\r\n\r\nlet hasOwnProperty = Object.prototype.hasOwnProperty\r\nexport const hasOwn = (target, key) => hasOwnProperty.call(target,key) //判断对象身上有没有这个属性\r\n\r\nexport const hasChanged = (oldValue,value) => oldValue !== value //判断老值和新值是否一致","import { isArray, isIntegerKey } from \"@vue/shared\";\r\nimport { TriggerOrTypes } from \"./operators\";\r\n\r\n/*\r\n * @Author: Pan Jingyi\r\n * @Date: 2022-10-12 10:30:07\r\n * @LastEditTime: 2022-10-13 09:58:59\r\n */\r\nexport function effect(fn, options:any = {}){\r\n  // 我需要让这个effect变成响应的effect，可以做到effect里面的数据变化：重新执行\r\n\r\n  const effect = createReactiveEffect(fn, options);\r\n\r\n  if(!options.lazy){ //lazy表示这个effect是懒执行，默认的effect会先执行一次\r\n    effect();\r\n  }\r\n\r\n  return effect;\r\n}\r\n\r\nlet uid  = 0;\r\nlet activeEffect;//一个变量：存储当前属性的effect\r\nconst effectStack = []; //栈：effect函数中可能会嵌套effect，那么就需要栈来存储当前属性的effect（区分）\r\nfunction createReactiveEffect(fn, options){ //fn就是用户传入的函数\r\n  const effect = function reactiveEffect(){\r\n    if(!effectStack.includes(effect)){ //如果没有再加进去：保证effect没有加入到effectStack中\r\n      //如果出现异常，希望还可以正常的将栈中元素抛出去\r\n      try{\r\n        effectStack.push(effect); //将当前属性的effect入栈\r\n        activeEffect = effect; //存储当前属性的effect\r\n        //让effect上来先执行一次,执行的是我们传入的那个函数: 执行就会去我们设置的变量中取值 \r\n        return fn();\r\n      }finally{\r\n        effectStack.pop();\r\n        activeEffect = effectStack[effectStack.length-1]\r\n      }\r\n    }\r\n    \r\n  }\r\n  effect.id = uid++; //制作一个effect标识，用于区分effect\r\n  effect._isEffect = true; //用于标识这个effect是响应式effect\r\n  effect.raw = fn; //保留effect对应的原函数\r\n  effect.options = options; //在effect上保存用户的属性\r\n\r\n  return effect;\r\n}\r\n\r\n// 让 某个对象中的属性 收集当前它对应的effect函数\r\nconst targetMap = new WeakMap()\r\nexport function track(target, type, key){\r\n  //这里可以拿到当前属性的effect： activeEffect\r\n\r\n  if(activeEffect === undefined){ //该属性不用收集effect\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * targetMap代表的是所有对象的集合：里面的key是每一个target，value是这个target的map\r\n   * depsMap代表的是某个target的map：它的value是map，这个map是target的所有属性的集合\r\n   * dep就是从targetMap中根据key(这里的key就是target)，然后拿到对应的depsMap，然后根据key(key就是某个属性)，找到这个属性的set\r\n   * 注意：每个属性对应一个set，然后这个set里面放了它的effect（因为set可以去重，所以是set）\r\n   * 如果这个set里面没有当前的effect，那就加上\r\n   */\r\n  let depsMap = targetMap.get(target)\r\n  if(!depsMap){\r\n    targetMap.set(target, (depsMap = new Map()))\r\n  }\r\n  let dep = depsMap.get(key)\r\n  if(!dep){\r\n    depsMap.set(key, (dep = new Set))\r\n  }\r\n  if(!dep.has(activeEffect)){\r\n    dep.add(activeEffect)\r\n  }\r\n\r\n  console.log(targetMap)\r\n}\r\n\r\nexport function trigger(target, type, key?, newValue?, oldValue?){\r\n  // target：我们代理的整个对象  type: 0/1 -> 新增/修改   key: 新增或修改的属性\r\n  // console.log('执行set或add',type, key, newValue, oldValue)\r\n  \r\n  /**\r\n   * targetMap是整个对象(即：let obj = reactive({name:'zs', age:12, arr: [1,2,3]}) )\r\n   * 那么 targetMap 就是 {name:'zs', age:12, arr: [1,2,3]}\r\n   * \r\n   * 这里的传参的target比如是：arr\r\n   * 那么depsMap就是[1,2,3]，但其实浏览器会自动加上一些方法：valueOf, toString, join, length，然后才是每一项：1,2,3\r\n   * 对于depsMap来说：它也有key和value：\r\n   * key就是valueOf, toString, join, length，每一项... \r\n   * value是一个set：这个set的值是function reactiveEffect()，对于function reactiveEffect()，这个函数的返回值是一个effect\r\n   * 也就是说，对于每个key(valueOf, toString, join, length，每一项... ),它的值是一个set，里面是它的effect\r\n   * 因为一个属性可能有好几个effect，所以用set\r\n   */\r\n  const depsMap = targetMap.get(target)\r\n  // 如果这个属性没有收集过effect，那就不需要做任何操作：就像我们在effect中写了一个不是reactive的属性并对他做修改，\r\n  if(!depsMap) return;\r\n\r\n  const effects = new Set()\r\n  // 将所有的要执行的effect 全部存到一个新的集合中，最终一起执行：就是把当前属性所依赖的所有effect存起来\r\n  const add = (effectsToAdd) => {\r\n    if(effectsToAdd){ //effectsToAdd是一个set，里面放了当前属性的所有effect\r\n      effectsToAdd.forEach(effect => effects.add(effect))\r\n    }\r\n  }\r\n\r\n  // 1.看修改的是不是数组的长度（因为改长度影响比较大）\r\n  if(key === 'length' && isArray(target)){\r\n    depsMap.forEach((dep, key) => {\r\n      // depsMap对于数组：前几项都是：valueOf, toString, join, length,下面几项是数组的每一项\r\n      // dep：是一个set，上面的depsMap的每一项的value：这个set的值是function reactiveEffect()\r\n      // key：valueOf, toString, join \r\n      // console.log('depsMap: ',depsMap,'dep: ', dep,'key: ', key)\r\n\r\n      if(key === 'length' || key > newValue){\r\n        // 如果更改的长度 小于收集的索引，那么这个索引也需要触发effect重新执行\r\n        add(dep);\r\n        //dep是一个set，是当前key的所有effect的集合\r\n      }\r\n    })\r\n  } else {\r\n    //修改的是对象\r\n    if(key !== undefined){ //这里肯定是修改，不是新增\r\n      add(depsMap.get(key))\r\n    }\r\n    //如果修改数组中的 某一个索引 怎么办？\r\n    switch(type){\r\n      case TriggerOrTypes.ADD: //这种情况：原来arr:[1,2,3]  但是现在：arr[100]=1\r\n        if(isArray(target) && isIntegerKey(key)){ //如果是数组并且修改的索引大于数组的长度(上面首先判断的是修改索引小于数组长度的情况)\r\n          add(depsMap.get('length'))\r\n        }\r\n    }\r\n  }\r\n\r\n  //取出所有effect，遍历\r\n  effects.forEach((effect:any) => effect())\r\n}\r\n\r\n// { name:'zf', age=12 } => name => [effect effect]","/*\r\n * @Author: Pan Jingyi\r\n * @Date: 2022-10-11 21:54:42\r\n * @LastEditTime: 2022-10-13 09:25:45\r\n */\r\n// 是不是仅读的 仅读的属性set时会报异常\r\n// 是不是深度的\r\n\r\nimport { extend, hasOwn, isIntegerKey, isObject, isArray, hasChanged } from '@vue/shared/src'\r\nimport { track, trigger } from './effect';\r\nimport { TrackOpTypes, TriggerOrTypes } from './operators';\r\nimport { reactive, readonly } from \"./reactive\";\r\n\r\nfunction createGetter(isReadonly = false, shallow = false){ //拦截获取功能\r\n  return function get(target, key, receiver){\r\n    \r\n    const res = Reflect.get(target, key, receiver)\r\n\r\n    if(!isReadonly){\r\n      //收集依赖，等会儿数据变化后更新对应的视图\r\n      //这里相当于属性值的最外面的一层，下面才是如果里层是对象进行递归\r\n    \r\n      //每个属性都会去走一遍这个函数\r\n      console.log('执行effect时会取值，收集effect')\r\n      track(target, TrackOpTypes.GET, key) //调用get方法时，追踪target对象的key属性\r\n    }\r\n\r\n    if(shallow){\r\n      return res\r\n    }\r\n    //如果不是浅读并且当前属性值是对象\r\n    if(isObject(res)){\r\n      //递归：保证属性值里面的对象仍然是响应式的\r\n      // vue2是一上来就递归，vue3是取值时才会代理（懒代理），如果你不用这个值就不会代理\r\n      return isReadonly ? readonly(res) : reactive(res)\r\n    }\r\n\r\n    return res\r\n  }\r\n}\r\n\r\nfunction createSetter(shallow = false){ //拦截设置功能\r\n  return function set(target, key, value, receiver){\r\n    // 首先判断是新增还是修改\r\n    const oldValue = target[key]; //获取老的值\r\n\r\n    // 判断key是否是数组并且是数组索引，如果是，该索引是已存在的还是新增的，如果不是数组判断该对象的属性key是否存在\r\n    // 这里就对数组和对象进行了区分\r\n    //我们也不需要像vue2那样去重写数组方法：因为push方法也是修改数组索引\r\n    let hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target,key)\r\n    // hadKey 此时就判断出来了该key是新增的还是修改\r\n\r\n    const result = Reflect.set(target, key, value, receiver)\r\n\r\n    if(!hadKey){\r\n      //新增\r\n      trigger(target, TriggerOrTypes.ADD, key, value)\r\n    }else if(hasChanged(oldValue,value)){//判断老值和新值是否一致\r\n      //修改\r\n      trigger(target, TriggerOrTypes.SET, key, value, oldValue)\r\n    }\r\n\r\n    // vue2里无法监控更改索引，无法监控数组的长度\r\n    // 当数据更新时，通知对应属性的effect重新执行\r\n    return result\r\n  }\r\n}\r\n\r\nconst get = createGetter()\r\nconst shallowGet = createGetter(false, true)\r\nconst readonlyGet = createGetter(true)\r\nconst shallowReadonlyGet = createGetter(true, true)\r\n\r\nconst set = createSetter()\r\nconst shallowSet = createSetter(true)\r\n\r\nexport const mutableHandlers = {\r\n  get,\r\n  set\r\n}\r\nexport const shallowReactiveHandlers = {\r\n  get: shallowGet,\r\n  set: shallowSet\r\n}\r\n\r\nlet readonlyObj = {\r\n  set: (target, key) => {\r\n    console.warn(`set on key ${key} failed`)\r\n  }\r\n}\r\n\r\nexport const readonlyHandlers = extend({\r\n  get: readonlyGet\r\n}, readonlyObj)\r\n\r\nexport const shallowReadonlyHandlers = extend({\r\n  get: shallowReadonlyGet\r\n}, readonlyObj)","/*\r\n * @Author: Pan Jingyi\r\n * @Date: 2022-10-11 21:20:53\r\n * @LastEditTime: 2022-10-12 10:07:38\r\n */\r\n\r\nimport { isObject } from '@vue/shared/src'\r\n\r\nimport {\r\n  mutableHandlers,\r\n  shallowReactiveHandlers,\r\n  readonlyHandlers,\r\n  shallowReadonlyHandlers\r\n} from './baseHandlers'\r\n\r\n\r\nexport function reactive(target){\r\n  return createReactiveObject(target, false, mutableHandlers)\r\n}\r\n\r\nexport function shallowReactive(target){\r\n  return createReactiveObject(target, false, shallowReactiveHandlers)\r\n}\r\n\r\nexport function readonly(target){\r\n  return createReactiveObject(target, true, readonlyHandlers)\r\n}\r\n\r\nexport function shallowReadonly(target){\r\n  return createReactiveObject(target, true, shallowReadonlyHandlers)\r\n}\r\n\r\n//是不是仅读，是不是深度， 柯里化 new Proxy() 最核心的需要拦截 数据的读取和数据的修改\r\n\r\nconst reactiveMap = new WeakMap()\r\nconst readonlyMap = new WeakMap()\r\n\r\nexport function createReactiveObject(target, isReadonly, baseHandlers){\r\n  //如果目标不是对象，没法拦截， reactive这个api只能拦截对象类型\r\n  if(!isObject(target)){\r\n    return target;\r\n  }\r\n\r\n  // 如果某个对象已经被代理过了 就不要再次代理了\r\n  // 可能一个对象 被深度代理了 又是仅读代理\r\n  const proxyMap = isReadonly? readonlyMap : reactiveMap; \r\n\r\n  const existProxy = proxyMap.get(target)\r\n  if(existProxy){\r\n    return existProxy; //如果已经被代理了，直接返回即可\r\n  }\r\n\r\n  const proxy = new Proxy(target, baseHandlers)\r\n  proxyMap.set(target, proxy) //将要代理的对象 和 对应代理结果缓存起来\r\n\r\n  return proxy\r\n}","/*\r\n * @Author: Pan Jingyi\r\n * @Date: 2022-10-13 10:16:50\r\n * @LastEditTime: 2022-10-13 10:32:23\r\n */\r\n\r\n// ref将普通的类型 转化成一个对象，这个对象中有个value属性 指向原来的值\r\n// let name = ref('zf')   name.value\r\nexport function ref(value){\r\n  return createRef(value)\r\n}\r\n\r\n// ref和reactive的区别：reactive内部采用proxy ref内部使用的是defineProperty\r\n\r\nexport function shallowRef(value){\r\n  return createRef(value,true)\r\n}\r\n\r\nclass RefImpl { //ref返回的是一个RefImpl类的实例\r\n  public _value; //表示声明了一个_value属性，但是没有赋值\r\n  public __v_isRef = true; //产生的实例会被添加 __v_isRef 表示是一个ref属性\r\n  constructor(public rawValue, public shallow){ //参数前面添加修饰符，该属性会被直接放到实例上 可以直接this.xxx获取\r\n    \r\n  }\r\n}\r\n\r\nfunction createRef(rawValue, shallow = false){\r\n  return new RefImpl(rawValue, shallow)\r\n}"],"names":[],"mappings":";;;;AAAA;;;;AAIG;AAEI,MAAM,QAAQ,GAAG,CAAC,KAAK,KAAK,OAAO,KAAK,IAAI,QAAQ,IAAI,KAAK,KAAK,IAAI,CAAC;AACvE,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAA;AAE5B,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,CAAA;AAI7B,MAAM,YAAY,GAAG,CAAC,GAAG,KAAK,QAAQ,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,GAAG,CAAA;AAE9D,IAAI,cAAc,GAAG,MAAM,CAAC,SAAS,CAAC,cAAc,CAAA;AAC7C,MAAM,MAAM,GAAG,CAAC,MAAM,EAAE,GAAG,KAAK,cAAc,CAAC,IAAI,CAAC,MAAM,EAAC,GAAG,CAAC,CAAA;AAE/D,MAAM,UAAU,GAAG,CAAC,QAAQ,EAAC,KAAK,KAAK,QAAQ,KAAK,KAAK,CAAA;;ACfhE;;;;AAIG;SACa,MAAM,CAAC,EAAE,EAAE,UAAc,EAAE,EAAA;;IAGzC,MAAM,MAAM,GAAG,oBAAoB,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC;AAEjD,IAAA,IAAG,CAAC,OAAO,CAAC,IAAI,EAAC;AACf,QAAA,MAAM,EAAE,CAAC;AACV,KAAA;AAED,IAAA,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,IAAI,GAAG,GAAI,CAAC,CAAC;AACb,IAAI,YAAY,CAAC;AACjB,MAAM,WAAW,GAAG,EAAE,CAAC;AACvB,SAAS,oBAAoB,CAAC,EAAE,EAAE,OAAO,EAAA;IACvC,MAAM,MAAM,GAAG,SAAS,cAAc,GAAA;QACpC,IAAG,CAAC,WAAW,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAC;;YAE/B,IAAG;AACD,gBAAA,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;AACzB,gBAAA,YAAY,GAAG,MAAM,CAAC;;gBAEtB,OAAO,EAAE,EAAE,CAAC;AACb,aAAA;AAAO,oBAAA;gBACN,WAAW,CAAC,GAAG,EAAE,CAAC;gBAClB,YAAY,GAAG,WAAW,CAAC,WAAW,CAAC,MAAM,GAAC,CAAC,CAAC,CAAA;AACjD,aAAA;AACF,SAAA;AAEH,KAAC,CAAA;AACD,IAAA,MAAM,CAAC,EAAE,GAAG,GAAG,EAAE,CAAC;AAClB,IAAA,MAAM,CAAC,SAAS,GAAG,IAAI,CAAC;AACxB,IAAA,MAAM,CAAC,GAAG,GAAG,EAAE,CAAC;AAChB,IAAA,MAAM,CAAC,OAAO,GAAG,OAAO,CAAC;AAEzB,IAAA,OAAO,MAAM,CAAC;AAChB,CAAC;AAED;AACA,MAAM,SAAS,GAAG,IAAI,OAAO,EAAE,CAAA;SACf,KAAK,CAAC,MAAM,EAAE,IAAI,EAAE,GAAG,EAAA;;AAGrC,IAAA,IAAG,YAAY,KAAK,SAAS,EAAC;QAC5B,OAAO;AACR,KAAA;AAED;;;;;;AAMG;IACH,IAAI,OAAO,GAAG,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CAAA;IACnC,IAAG,CAAC,OAAO,EAAC;AACV,QAAA,SAAS,CAAC,GAAG,CAAC,MAAM,GAAG,OAAO,GAAG,IAAI,GAAG,EAAE,EAAE,CAAA;AAC7C,KAAA;IACD,IAAI,GAAG,GAAG,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAA;IAC1B,IAAG,CAAC,GAAG,EAAC;AACN,QAAA,OAAO,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,EAAE,CAAA;AAClC,KAAA;AACD,IAAA,IAAG,CAAC,GAAG,CAAC,GAAG,CAAC,YAAY,CAAC,EAAC;AACxB,QAAA,GAAG,CAAC,GAAG,CAAC,YAAY,CAAC,CAAA;AACtB,KAAA;AAED,IAAA,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,CAAA;AACxB,CAAC;AAEK,SAAU,OAAO,CAAC,MAAM,EAAE,IAAI,EAAE,GAAI,EAAE,QAAS,EAAE,QAAS,EAAA;;;AAI9D;;;;;;;;;;;AAWG;IACH,MAAM,OAAO,GAAG,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CAAA;;AAErC,IAAA,IAAG,CAAC,OAAO;QAAE,OAAO;AAEpB,IAAA,MAAM,OAAO,GAAG,IAAI,GAAG,EAAE,CAAA;;AAEzB,IAAA,MAAM,GAAG,GAAG,CAAC,YAAY,KAAI;QAC3B,IAAG,YAAY,EAAC;AACd,YAAA,YAAY,CAAC,OAAO,CAAC,MAAM,IAAI,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAA;AACpD,SAAA;AACH,KAAC,CAAA;;IAGD,IAAG,GAAG,KAAK,QAAQ,IAAI,OAAO,CAAC,MAAM,CAAC,EAAC;QACrC,OAAO,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,GAAG,KAAI;;;;;AAM3B,YAAA,IAAG,GAAG,KAAK,QAAQ,IAAI,GAAG,GAAG,QAAQ,EAAC;;gBAEpC,GAAG,CAAC,GAAG,CAAC,CAAC;;AAEV,aAAA;AACH,SAAC,CAAC,CAAA;AACH,KAAA;AAAM,SAAA;;AAEL,QAAA,IAAG,GAAG,KAAK,SAAS,EAAC;YACnB,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAA;AACtB,SAAA;;AAED,QAAA,QAAO,IAAI;AACT,YAAA,KAAA,CAAA;gBACE,IAAG,OAAO,CAAC,MAAM,CAAC,IAAI,YAAY,CAAC,GAAG,CAAC,EAAC;oBACtC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAA;AAC3B,iBAAA;AACJ,SAAA;AACF,KAAA;;IAGD,OAAO,CAAC,OAAO,CAAC,CAAC,MAAU,KAAK,MAAM,EAAE,CAAC,CAAA;AAC3C,CAAC;AAED;;AC1IA;;;;AAIG;AASH,SAAS,YAAY,CAAC,UAAU,GAAG,KAAK,EAAE,OAAO,GAAG,KAAK,EAAA;AACvD,IAAA,OAAO,SAAS,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,QAAQ,EAAA;AAEvC,QAAA,MAAM,GAAG,GAAG,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,QAAQ,CAAC,CAAA;QAE9C,IAAG,CAAC,UAAU,EAAC;;;;AAKb,YAAA,OAAO,CAAC,GAAG,CAAC,uBAAuB,CAAC,CAAA;AACpC,YAAA,KAAK,CAAC,MAAM,EAAA,CAAA,yBAAoB,GAAG,CAAC,CAAA;AACrC,SAAA;AAED,QAAA,IAAG,OAAO,EAAC;AACT,YAAA,OAAO,GAAG,CAAA;AACX,SAAA;;AAED,QAAA,IAAG,QAAQ,CAAC,GAAG,CAAC,EAAC;;;AAGf,YAAA,OAAO,UAAU,GAAG,QAAQ,CAAC,GAAG,CAAC,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAA;AAClD,SAAA;AAED,QAAA,OAAO,GAAG,CAAA;AACZ,KAAC,CAAA;AACH,CAAC;AAED,SAAS,YAAY,CAAC,OAAO,GAAG,KAAK,EAAA;IACnC,OAAO,SAAS,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,QAAQ,EAAA;;QAE9C,MAAM,QAAQ,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;;;;AAK7B,QAAA,IAAI,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC,IAAI,YAAY,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,EAAC,GAAG,CAAC,CAAA;;AAGpG,QAAA,MAAM,MAAM,GAAG,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAA;QAExD,IAAG,CAAC,MAAM,EAAC;;AAET,YAAA,OAAO,CAAC,MAAM,EAAA,CAAA,2BAAsB,GAAG,EAAE,KAAK,CAAC,CAAA;AAChD,SAAA;aAAK,IAAG,UAAU,CAAC,QAAQ,EAAC,KAAK,CAAC,EAAC;;YAElC,OAAO,CAAC,MAAM,EAAsB,CAAA,2BAAA,GAAG,EAAE,KAAe,CAAC,CAAA;AAC1D,SAAA;;;AAID,QAAA,OAAO,MAAM,CAAA;AACf,KAAC,CAAA;AACH,CAAC;AAED,MAAM,GAAG,GAAG,YAAY,EAAE,CAAA;AAC1B,MAAM,UAAU,GAAG,YAAY,CAAC,KAAK,EAAE,IAAI,CAAC,CAAA;AAC5C,MAAM,WAAW,GAAG,YAAY,CAAC,IAAI,CAAC,CAAA;AACtC,MAAM,kBAAkB,GAAG,YAAY,CAAC,IAAI,EAAE,IAAI,CAAC,CAAA;AAEnD,MAAM,GAAG,GAAG,YAAY,EAAE,CAAA;AAC1B,MAAM,UAAU,GAAG,YAAY,CAAC,IAAI,CAAC,CAAA;AAE9B,MAAM,eAAe,GAAG;IAC7B,GAAG;IACH,GAAG;CACJ,CAAA;AACM,MAAM,uBAAuB,GAAG;AACrC,IAAA,GAAG,EAAE,UAAU;AACf,IAAA,GAAG,EAAE,UAAU;CAChB,CAAA;AAED,IAAI,WAAW,GAAG;AAChB,IAAA,GAAG,EAAE,CAAC,MAAM,EAAE,GAAG,KAAI;AACnB,QAAA,OAAO,CAAC,IAAI,CAAC,cAAc,GAAG,CAAA,OAAA,CAAS,CAAC,CAAA;KACzC;CACF,CAAA;AAEM,MAAM,gBAAgB,GAAG,MAAM,CAAC;AACrC,IAAA,GAAG,EAAE,WAAW;CACjB,EAAE,WAAW,CAAC,CAAA;AAER,MAAM,uBAAuB,GAAG,MAAM,CAAC;AAC5C,IAAA,GAAG,EAAE,kBAAkB;CACxB,EAAE,WAAW,CAAC;;ACjGf;;;;AAIG;AAYG,SAAU,QAAQ,CAAC,MAAM,EAAA;IAC7B,OAAO,oBAAoB,CAAC,MAAM,EAAE,KAAK,EAAE,eAAe,CAAC,CAAA;AAC7D,CAAC;AAEK,SAAU,eAAe,CAAC,MAAM,EAAA;IACpC,OAAO,oBAAoB,CAAC,MAAM,EAAE,KAAK,EAAE,uBAAuB,CAAC,CAAA;AACrE,CAAC;AAEK,SAAU,QAAQ,CAAC,MAAM,EAAA;IAC7B,OAAO,oBAAoB,CAAC,MAAM,EAAE,IAAI,EAAE,gBAAgB,CAAC,CAAA;AAC7D,CAAC;AAEK,SAAU,eAAe,CAAC,MAAM,EAAA;IACpC,OAAO,oBAAoB,CAAC,MAAM,EAAE,IAAI,EAAE,uBAAuB,CAAC,CAAA;AACpE,CAAC;AAED;AAEA,MAAM,WAAW,GAAG,IAAI,OAAO,EAAE,CAAA;AACjC,MAAM,WAAW,GAAG,IAAI,OAAO,EAAE,CAAA;SAEjB,oBAAoB,CAAC,MAAM,EAAE,UAAU,EAAE,YAAY,EAAA;;AAEnE,IAAA,IAAG,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAC;AACnB,QAAA,OAAO,MAAM,CAAC;AACf,KAAA;;;IAID,MAAM,QAAQ,GAAG,UAAU,GAAE,WAAW,GAAG,WAAW,CAAC;IAEvD,MAAM,UAAU,GAAG,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,CAAA;AACvC,IAAA,IAAG,UAAU,EAAC;QACZ,OAAO,UAAU,CAAC;AACnB,KAAA;IAED,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,MAAM,EAAE,YAAY,CAAC,CAAA;IAC7C,QAAQ,CAAC,GAAG,CAAC,MAAM,EAAE,KAAK,CAAC,CAAA;AAE3B,IAAA,OAAO,KAAK,CAAA;AACd;;ACxDA;;;;AAIG;AAEH;AACA;AACM,SAAU,GAAG,CAAC,KAAK,EAAA;AACvB,IAAA,OAAO,SAAS,CAAC,KAAK,CAAC,CAAA;AACzB,CAAC;AAED;AAEM,SAAU,UAAU,CAAC,KAAK,EAAA;AAC9B,IAAA,OAAO,SAAS,CAAC,KAAK,EAAC,IAAI,CAAC,CAAA;AAC9B,CAAC;AAED,MAAM,OAAO,CAAA;AAGQ,IAAA,QAAA,CAAA;AAAiB,IAAA,OAAA,CAAA;IAF7B,MAAM,CAAC;AACP,IAAA,SAAS,GAAG,IAAI,CAAC;IACxB,WAAmB,CAAA,QAAQ,EAAS,OAAO,EAAA;QAAxB,IAAQ,CAAA,QAAA,GAAR,QAAQ,CAAA;QAAS,IAAO,CAAA,OAAA,GAAP,OAAO,CAAA;KAE1C;AACF,CAAA;AAED,SAAS,SAAS,CAAC,QAAQ,EAAE,OAAO,GAAG,KAAK,EAAA;AAC1C,IAAA,OAAO,IAAI,OAAO,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAA;AACvC;;;;;;;;;;"}